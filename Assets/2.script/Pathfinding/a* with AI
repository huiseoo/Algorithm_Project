A* 알고리즘은 최단 경로를 찾는 대표적인 경로탐색 알고리즘으로, 제공된 코드에서 플레이어 캐릭터의 이동 경로를 찾는데 활용된다.

### A* 알고리즘의 기본 구조와 원리

A* 알고리즘은 시작 노드에서 목표 노드까지의 최적 경로를 다음의 비용 함수로 찾는다:

F(n) = G(n) + H(n)

여기서:
- G(n)은 시작점에서 현재 노드까지의 실제 이동 비용을 나타낸다
- H(n)은 현재 노드에서 목표까지의 추정 비용(휴리스틱)을 계산한다
- F(n)은 이 둘을 합한 총 예상 비용을 의미한다

이러한 구조는 코드에서 Node 클래스를 통해 다음과 같이 구현한다:
```csharp
public class Node
{
    public Vector2Int Position;   // 노드의 위치를 저장한다
    public float G;              // 시작점부터의 실제 비용을 나타낸다
    public float H;              // 목표까지의 추정 비용을 저장한다
    public float F => G + H;     // 총 예상 비용을 계산한다
    public Node Parent;          // 경로 추적용 이전 노드를 참조한다
}
```

### 실제 게임에서의 적용 과정

1. 경로 탐색 시작:
PlayerControllerWithPathfinding에서 마우스 클릭을 감지하면, 현재 위치에서 목표 위치까지의 경로를 찾기 시작한다. 이 과정은 다음과 같이 진행된다:

- 현재 위치(currentGridPos)와 목표 위치(goalGridPos)를 설정한다
- 장애물 정보를 수집한다 (GetObstacles 메서드 사용)
- A* 알고리즘을 통한 경로 탐색을 시작한다

2. 휴리스틱 함수 활용:
맨해튼 거리를 휴리스틱으로 사용하여 목표까지의 예상 거리를 다음과 같이 계산한다:
```csharp
private float GetHeuristic(Vector2Int a, Vector2Int b)
{
    return Mathf.Abs(a.x - b.x) + Mathf.Abs(a.y - b.y);
}
```

3. 반복적 경로 탐색:
FindPath 메서드에서는 다음과 같은 주요 자료구조를 사용한다:
```csharp
List<Node> openList = new List<Node>();        // 탐색할 노드들을 저장한다
HashSet<Vector2Int> closedList = new HashSet<Vector2Int>();  // 탐색 완료된 노드들을 기록한다
```

이를 통해:
- openList에서 F값이 가장 작은 노드를 선택한다
- 선택된 노드의 상하좌우 이웃 노드들을 탐색한다
- 각 이웃 노드의 비용(G, H, F)을 계산한다
- 장애물을 피해가며 경로를 확장한다

4. 경로 생성 및 이동:
목표점에 도달하면 Parent 노드들을 역추적하여 최종 경로를 생성하고, FollowPath 코루틴을 통해 실제 캐릭터 이동에 사용한다.

### 구현의 특징과 장점

1. 효율적인 장애물 처리:
HashSet을 사용하여 O(1) 시간 복잡도로 장애물 검사가 가능하다.

2. 그리드 기반 단순화:
- 4방향 이동만 허용하여 경로 탐색 복잡도를 낮춘다
- 맨해튼 거리를 휴리스틱으로 사용하여 정확한 추정 비용을 계산한다

3. 실시간 경로 탐색:
플레이어의 입력에 따라 즉시 새로운 경로를 계산하고 적용할 수 있다.

이렇게 구현된 A* 알고리즘은 최적의 경로를 보장하면서도, 휴리스틱을 통해 탐색 공간을 효율적으로 줄이는 장점을 가지며, 실제 게임에서 자연스러운 캐릭터 이동을 가능하게 한다.
